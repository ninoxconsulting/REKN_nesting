---
title: "Summary Rekn Nesting"
author: "Gen Perkins"
date: "2025-05-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1.Basic summary

An initial compilation was completed for existing compiled Red Knot GPS/satellite data (2021 - 2023 Dec). A full analysis of this data was reported on in 2024. 

Since this data compilation, other satellite tags have been deployed (Dec 2023 - current). These were obtained directly from movebank with all data extracted regardless of if metadata was available. The data was compiled from the following projects:ECCC, Southeast USA to Arctic, spring_USFWS, David Newstead and Mispillion. 
Two of these projects (ECCC and Southeast USA to Arctic) had ongoing and new deployments for Red Knots in 2024 breeding season of 2024. 

Potential there are more that were not available through movebank (Yves?, Newstead, Christian?)

### Data summary: 

I firstly combined data from 2023 and 2024 and reviewed which individuals were recorded within the breeding grounds. 

```{r libraries, include=FALSE}
#libraries
library(fs)
#remotes::install_github("picardis/nestR", build_vignettes = TRUE, force = TRUE)
library(nestR)
require(recurse)
require(scales)
library(readr)
library(adehabitatHR)
library("rnaturalearth")
library("rnaturalearthdata")
library(ggplot2)
library(stringr)
library(readxl)
library(foreach)
library(tidyverse)
library(lubridate)
library(leaflet)
library(RColorBrewer)
library(dplyr)
library(sf)



# read in the datasets 
# pre 2023

b23 <- st_read(path("temp", "birds_2023.gpkg"))  |> 
  select(-algorithm.marked.outlier, -date_time) 
  
# 2024/25
b24 <- st_read(path("temp", "birds_2024.gpkg")) |> 
  select(-algorithm.marked.outlier, -date_time)

all <- bind_rows(b24, b23) |> 
  select(-c(stopover, movement_temp, id, bearing, gcd_m, speed_mhr ))


# check the number of individuals
all_birds <- length(unique(all$tag.id))

# 95 tags showed arrival at breding grounds 

# list of birds with the summary of movement patterns
reknbr <- read_csv(path("data", "final_tags_list_edited.csv")) |> 
  filter(breeding =="y") |> 
  filter(subspecies == "rufa")

reknbr_full <- reknbr |> 
  filter(south == "y")
  
  
# add other specific tags 
reknbr_fullid <- c(reknbr_full$tag.id, 260805, 262940)
                
# select the individuals with breeding locations 
breed <- all |> filter(tag.id %in% reknbr_fullid) 

all_birds_full <- length(unique(breed$tag.id))

```

A total of **`r all_birds`** individuals were recorded within the breeding grounds. Of these 
**`r all_birds_full`** individuals were recorded returning southwards and were considerd with a full breeding season. 

These comprised the following tag types: 

```{r tag types, echo = FALSE}
breed <- breed |> 
  mutate(tag.model1 = case_when(
    tag.model == "sunbird"~ "Sunbird Solar Argos", 
    tag.model == "Sunbird"~ "Sunbird Solar Argos", 
    .default = tag.model))
breed  |> 
   st_drop_geometry() |> 
   select(tag.id, tag.model1) |> 
   distinct() |> 
   group_by(tag.model1) |> 
   count()

```

With the bulk of the locations (n) being recorded with Sunbird tag type. One tag was not assigned a tag.model as there was missing reference data however this appears to be a sunbird based on the frequency of recordings. 

```{r echo = FALSE}
breed  |> 
  st_drop_geometry() |> 
   group_by(tag.model1) |> 
   count()
```

# 2. Accuracy and tag types

Argos uses two independent methods for estimating locations: 1) via Global Positioning System (GPS) (Pinpoint GPS Argos 75) or 2) via Doppler shift calculations (Sunbird Solar Argos and Solar PTT tags) (Argos 2016). For GPS tags, such as Pinpoints, each location is acquired independently using GPS positioning which has an estimated error of less than 100 meters. Alternatively, location data from Sunbird and Solar PTT tags is based on estimating the Doppler shift in signal frequency of successive transmissions. Each Doppler shift location is categorized into an accuracy class based on the estimated uncertainty radius surrounding the location (Table 2). For example, Doppler Shift Class 1 locations are accurate to within a radius of 500 to 1500 meters.  All locations derived from the Argos System are reported in coordinates (latitude and longitude) using the World Geodetic System 1984 (WGS 84) reference system. 

Table 2: Accuracy estimates (meter) for class of transmitted location derived via GPS positioning or Argos Doppler shift calculations.

```
Type,	              Class,	   Estimated Error (meters),

GPS Positioning,	    G,	     <100 m
Argos Doppler Shift,	3,	     < 250 m 
Argos Doppler Shift,	2,	     > 250 m and < 500 m 
Argos Doppler Shift,	1,	     > 500 m and < 1500 m
Argos Doppler Shift,	0, 	     > 1500 m radius
Argos Doppler Shift,	A,     	Unbounded accuracy estimation (3 messages)
Argos Doppler Shift,	B, 	    Unbounded accuracy estimation (1 or 2 messages)
Argos Doppler Shift,	Z,	    Invalid Location

```
Lotek PinPoint GPS – Argos 75 was less common tag model in this dataset with 8 out of 37 tags. This model was first deployed on Red Knots in 2014 and represents the first GPS tag suitable for small migrant birds with a weight of ~3.5 - 4 grams (Scarpignato et al. 2016). PinPoint tags use GPS locations and are the most accurate of the three tag types with less than 100 m of error (Argos 2016). Prior to deployment, researchers set a frequency and duration schedule at which location information is collected and the results transmitted. The frequency at which data acquisition and transmission is set will determine the overall duration of the tag, which has a finite battery capacity, limited to approximately 60 locations. 

Lotek Sunbird Solar Argos and Microwave Telemetry Solar 2g PTT tags are lighter (~ 2 grams) than PinPoint tags and have solar rechargeable batteries. This consisted of 29 out of 37 tags reviewed. These tags use Doppler shift estimates rather than GPS to determine locations, which provides a lower power consumption. These two features enable these tags to maintain lightweight capability and increase duration of tracking.  Overall, the accuracy of these tags is lower (± a minimum of 250 m) as compared to GPS derived data. The Lotek Sunbird Solar Argos tag has a programable schedule for data acquisition and transmission, while the Solar 2g PTT transmits continuously. 




## 3. Breeding location estimates 

Each tag was reviewed to assess rough beginning and end dates for the individual based on a concentrated locations. This varied per individual.

The plot below shows the centroid of the breeding location for each bird for summary purposes. 

```{r breeding location, echo=FALSE}

cc <- st_read(path("temp", "centroid_breeding.gpkg"), quiet = TRUE) 

cc <- cc|> 
  cbind(st_coordinates(cc)) |> 
  mutate(tag.id = as.factor(tag.id))

world <- ne_countries(scale = "medium", returnclass = "sf")

Americas <- world %>% dplyr::filter(continent == "North America")

# entire north America 
global_north <- ggplot(data = Americas) +
  geom_sf(color = "grey") +
  geom_point(data = cc, aes(x = X, y = Y, colour = tag.id), size = 2) +#colour = "dark blue") +
  scale_color_viridis_d() + 
  coord_sf(xlim = c(-120, -60), ylim = c(60, 75), expand = FALSE)+
  theme_bw()+
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    legend.position="none"
    #legend.position = "bottom",
    #legend.key.width = unit(3, "lines")
  )

global_north

```

Figure 1: Estimated centroid position for each breeding individual to complete full breeding season (2021 - 2024). n = 37 individuals. 

### 3.1 Breeding Accuracy plots per individual

Based on an estimated breeding window for each birds, the proportion of locations by type are as follows. The accuracy from highest to lowest is 3,2,1,0 with A and B being unknown accuracy. 


```{r, echo = FALSE}

bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |> 
  filter(breeding == "y") 

bb_accuracy <- bb |> 
  st_drop_geometry() |> 
  group_by(tag.id, argos.lc) |>
  count()


# plot the type of sensor.type by indiviudal and accuracy rating

pt <- ggplot(bb_accuracy, aes(x = argos.lc, y = n)) +
  geom_bar(stat = "identity") +
  #scale_fill_manual(values = c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00")) +
  facet_wrap(~tag.id, scales = "free_y" )+
  labs(x = "Tag ID", y = "number of breding record by accuracy type") +
  #theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme_bw()# + 
  #theme(legend.position="none")
```

```{r, echo = FALSE, fig.width = 10, fig.height = 8, fig.cap=" Figure 2. Proportion of breeding record by accuracy type per individual"}
pt
```


### 3.2 Duration of breeding season 

From the 37 individuals who had a full breeding season before heading southwards, we can review the duration of the breeding period. 

```{r, echo = FALSE, messages = FALSE, warning = FALSE}

bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE)

###############################
bb <- bb |> filter(breeding == 'y') |> 
  filter(tag.id != 260805) |> # remove the two tags with no return 
  filter(tag.id != 262940)

# get duration for each tag id

bb_dir <- bb %>% 
  group_by(tag.id) %>% 
  summarise(start = min(date), end = max(date)) |>
  mutate(duration = as.numeric(end - start)) |> 
  st_drop_geometry() 

aa <- bb_dir %>% 
  as_tibble() %>%
  mutate(start = week(start),
         end = week(end)) %>% 
  tidyr::pivot_longer(-1) %>% 
  #separate(col = name, into = c("name", "index"), sep = "_", fill = "right") %>%  
  #mutate(index = ifelse(is.na(index), 1, index)) %>% 
   tidyr::pivot_wider(names_from = "name", values_from = "value") 

ab<-  ggplot(aa, aes(y=as.factor(tag.id), x=start, xend=end)) + 
   geom_segment(size = 2)+
   scale_x_continuous(limits = c(21, 36), breaks = seq(21, 36, 2)) +
  labs(x = "week of year", y = "Tag ID", title = "Breeding duration for Red Knots")+
  theme_bw()

ab

#min(bb_dir$duration) 
#mean(bb_dir$duration) # 37 days
#max(bb_dir$duration) # 60 days
#median(bb_dir$duration)

```

The minimum breeding duration was `r min(bb_dir$duration)` days, the mean was `r round(mean(bb_dir$duration),0)` days, the maximum was `r max(bb_dir$duration)` days.


### 3.3 Preliminary detailed case studies. 

I reviewed a number of individuals in detail to assess detailed breeding locations. These included tag.id #260803 and #238544, #260805, 262940 (all nesting in Southampton island ). Tag #262940 could have been dropped at the nest location or the bird died, as the pattern appears very circular with error around a single point 


### **Tag id = 260803**

```{r, echo = FALSE}

bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |> 
  filter(breeding == "y") |> 
  filter(tag.id == 260803) 

bb <- cbind(st_coordinates(bb), bb)

# plot 
world <- ne_countries(scale = "medium", returnclass = "sf")

Americas <- world %>% dplyr::filter(continent == "North America")

# entire north America 
global_north <- ggplot(data = Americas) +
  geom_sf(color = "grey") +
  geom_point(data = bb, aes(x = X, y = Y, colour = argos.lc), size = 2) +#colour = "dark blue") +
  scale_color_viridis_d() + 
  #facet_wrap(~tag.id)+
  # geom_point(ru, aes(x = lng, y = lat), size = 4) +
  # xlab("Longitude") + ylab("Latitude") +
  #coord_sf(xlim = c(-130, -20), ylim = c(-50, 80), expand = FALSE)+
  coord_sf(xlim = c(-89, -81), ylim = c(62.5, 65), expand = FALSE)+
  theme_bw()+
  #labs(colour = "Subpopulation") + 
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    #legend.position="none"
    legend.position = "bottom",
    legend.key.width = unit(3, "lines")
  )

global_north

```


### **Tag id = 238544**

```{r, echo = FALSE}

bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |> 
  filter(breeding == "y") |> 
  filter(tag.id == 238544) 

bb <- cbind(st_coordinates(bb), bb)

# plot 
world <- ne_countries(scale = "medium", returnclass = "sf")

Americas <- world %>% dplyr::filter(continent == "North America")

# entire north America 
global_north <- ggplot(data = Americas) +
  geom_sf(color = "grey") +
  geom_point(data = bb, aes(x = X, y = Y, colour = argos.lc), size = 2) +#colour = "dark blue") +
  scale_color_viridis_d() + 
  #facet_wrap(~tag.id)+
  # geom_point(ru, aes(x = lng, y = lat), size = 4) +
  # xlab("Longitude") + ylab("Latitude") +
  #coord_sf(xlim = c(-130, -20), ylim = c(-50, 80), expand = FALSE)+
  coord_sf(xlim = c(-89, -81), ylim = c(62.5, 65), expand = FALSE)+
  theme_bw()+
  #labs(colour = "Subpopulation") + 
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    #legend.position="none"
    legend.position = "bottom",
    legend.key.width = unit(3, "lines")
  )

global_north

```



### **Tag id = 260805**

```{r, echo = FALSE}

bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |> 
  filter(breeding == "y") |> 
  filter(tag.id == 260805) 

bb <- cbind(st_coordinates(bb), bb)

# plot 
world <- ne_countries(scale = "medium", returnclass = "sf")

Americas <- world %>% dplyr::filter(continent == "North America")

# entire north America 
global_north <- ggplot(data = Americas) +
  geom_sf(color = "grey") +
  geom_point(data = bb, aes(x = X, y = Y, colour = argos.lc), size = 2) +#colour = "dark blue") +
  scale_color_viridis_d() + 
  coord_sf(xlim = c(-85, -80), ylim = c(62.5, 64.5), expand = FALSE)+
  theme_bw()+
  #labs(colour = "Subpopulation") + 
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    #legend.position="none"
    legend.position = "bottom",
    legend.key.width = unit(3, "lines")
  )

global_north

```


## **Tag #262940**

This tag is likely stationary and was either dropped from the bird, or the bird died. This provides an interesting example of potential drift or uncertainty around a stationary point. 

```{r, echo = FALSE, messages = FALSE, warning = FALSE}

bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |> 
  filter(breeding == "y") |> 
  filter(tag.id == 262940) 

bb <- cbind(st_coordinates(bb), bb)

# plot 
world <- ne_countries(scale = "medium", returnclass = "sf")

Americas <- world %>% dplyr::filter(continent == "North America")

# entire north America 
global_north <- ggplot(data = Americas) +
  geom_sf(color = "grey") +
  geom_point(data = bb, aes(x = X, y = Y, colour = argos.lc), size = 2) +#colour = "dark blue") +
  scale_color_viridis_d() + 
  coord_sf(xlim = c(-88, -84), ylim = c(64.5, 65.5), expand = FALSE)+
  theme_bw()+
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    axis.title = element_blank(),
    #legend.position="none"
    legend.position = "bottom",
    legend.key.width = unit(3, "lines")
  )

global_north

```


We can review the location of the points to assess the drift and or accuracy of points.To have an idea of the scale for each of these data types we applied a buffer of 250m for class 3 and 500 for class 2.  


```{r, echo = FALSE, messages = FALSE, warning = FALSE}

bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |> 
  filter(breeding == "y") |> 
  filter(tag.id == 262940) |> 
  filter(argos.lc %in% c("3", "2"))

bb <- cbind(st_coordinates(bb), bb) |> 
  select(tag.id, argos.lc, X, Y, date) 


pl <- ggplot(bb)+
geom_point(data = bb, aes(x = X, y = Y, colour = argos.lc), size = 2)+
facet_wrap(~argos.lc)+
theme_bw()

```


Figure: Recorded points with error buffers for tag id: 262940, based on 250m (argos.lc = 3) and 500m buffer (argos.lc = 2)


```{r, echo = FALSE, messages = FALSE, warning = FALSE,fig.width = 10, fig.height = 4}
bbm <- st_transform(bb, crs = 3573)

bbm250 <- st_buffer(bbm, dist = 250) |> 
  st_make_valid() |> 
  st_union() |> 
  st_as_sf() |> 
  st_transform(crs = 4326) 

bbm500 <- st_buffer(bbm, dist = 500) |> 
  st_make_valid() |> 
  st_union() |> 
  st_as_sf() |> 
  st_transform(crs = 4326) 

pl <- ggplot(bb)+
#geom_point(data = bb, aes(x = X, y = Y, colour = argos.lc), size = 2)+
geom_sf(data = bbm500, aes(fill = "500m_buffer"), alpha = 0.3)+
  geom_sf(data = bbm250, aes(fill = "250m_buffer"), alpha = 0.3)+
facet_wrap(~argos.lc)+
geom_point(data = bb, aes(x = X, y = Y, colour = argos.lc), size = 2)+
theme_bw()

pl

a1 <- round(as.numeric(st_area(bbm250)/1000000),1)

a2 <- round(as.numeric(st_area(bbm500)/1000000),1)


```

The area within the 250m buffer is `r a1` km2 and the area within the 500m buffer is `r a2` km2. This is potentially a very large areas to search! 



## 4. Options for nest detections. 

There are a number of general analysis approaches or more specific that could be applied to estimate the nest locations. 

1. Kernel Density Estimates (kde) are a popular method to estimate the distribution of data, hence are used to estimate home ranges. Calculations for KDE require consideration of the mathematical method to describe the density function. A detailed description of the parameters can be found [here](https://www.spatialecology.com/gme/kde). These methods are quite sensitive to methods and parameters selected. A test of these methods was trialed for a few test cases with very broad results. 

2. Other clustering methods (e.g., DBSCAN, K-means, Hidden Markov Models, etc.) can be used to identify clusters of points in time and space. Some R packages exist to undertake these analysis (ctmm, momentuHMM)

3. Recursive movement analysis (recurse, nestR). Rather than a density metric, this approach relies on movement of an individual exhibiting back-and-forth movements to and from their nest.  The premise is that repeatedly visited locations can be identified along movement trajectories, and patterns of revisitation can be used to determine whether a location that gets visited repeatedly is likely to be a nest. NestR package provides functions to identify nests and estimate success based on the underlying assumption that the nest stops being revisited after an attempt fails. 

4. Combined methods using GPS location and details on the movement information (accelerometer data) to detect nests. 
https://animalbiotelemetry.biomedcentral.com/articles/10.1186/s40317-024-00385-y


### Testing Outputs: 

Using the tag.id 262940 I ran through the above methods to estimate search location for the nest. These estimates used only argos accuracy type classes of 2 and 3. 

1) Kernel Density Estimates (kde)

I estimated the 95%, 75% and 50% home range estimated for KDE methods using two different methods (href) and least square cross validation(lscv). These provide bounding areas based on a density estimate. 

```{r echo = FALSE, message = FALSE, warning = FALSE,fig.width = 10, fig.height = 4, fig.cap=" Figure: Kernal Density Estimates using two methods"}

##########################################################################
## method 1: Kernal density estimates

bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |> 
  dplyr::filter(breeding == "y") |> 
  dplyr::filter(tag.id == 262940) |> 
  dplyr::filter(argos.lc %in% c("3", "2"))

bb <- cbind(st_coordinates(bb), bb) |> 
  dplyr::select(tag.id, argos.lc, X, Y, date) 

tdfgeo <- bb |>
  dplyr::select(tag.id) |>
  as("Spatial")


## 3.1 kde: h reference parameter
# define the parameters (h, kern, grid, extent)

kde_href <- kernelUD(tdfgeo, h = "href", kern = c("bivnorm"), grid = 500, extent = 2)
ver95 <- getverticeshr(kde_href, 95) # get vertices for home range
ver95_sf <- st_as_sf(ver95) # convert to sf object
ver75 <- getverticeshr(kde_href, 75)
ver75_sf <- st_as_sf(ver75)
ver50 <- getverticeshr(kde_href, 50)
ver50_sf <- st_as_sf(ver50)

## 3.2 kde: Least Squares Cross Validation (lscv) method.

kde_lscv <- kernelUD(tdfgeo, h = "LSCV", kern = c("bivnorm"), grid = 500, extent = 2)
ver95ls <- getverticeshr(kde_lscv, 95) # get vertices for home range
ver95ls_sf <- st_as_sf(ver95ls)
ver50ls <- getverticeshr(kde_lscv, 50)
ver50ls_sf <- st_as_sf(ver50ls)

# bind all data together
all_verts <- bind_rows(ver95_sf, ver75_sf, ver50_sf) |> mutate(type = "href")
all_vertsls <- bind_rows(ver95ls_sf, ver50ls_sf)|> mutate(type = "lscv")

all_verts <- bind_rows(all_verts,all_vertsls)

area <- all_verts |> 
  st_cast("POLYGON") |> 
  st_make_valid() |>
  mutate(area_m2 = st_area(geometry)) |> 
  mutate(area_km2 = round(as.numeric(area_m2)/1000000,2)) |>
  dplyr::select(-area, -area_m2) |> 
  st_drop_geometry() |>
  dplyr::select(id, type, area_km2) 


names = c("href_50%", "href_75%", "href_95%", "lscv_50%", "lscv_95%")

area1 <- cbind(area, names) 
row.names(area1) <- NULL

area1 <- area1 |> 
  dplyr::select(id, type, names, area_km2) 

  
# lets plot the output
ggplot(data = all_verts) +
   geom_sf(data = bb, aes(colour = argos.lc, ), size = 1, alpha = 0.1)+
  geom_sf(
    aes(colour = id),
    alpha = 0.1
  ) +
  #scale_colour_viridis_d() +
  facet_wrap(vars(type)) +
  theme_bw()


```

This provides a more defined area for search radius with the potential areas of less than 1km. 

```{r}
area1
```


2) [Recurse Package](https://cran.r-project.org/web/packages/recurse/vignettes/recurse.html)

We can also estimate the nest location and perform a cluster analysis using a recursive approach.
This provides an estimate of the number of revisits to a location, based on user defined metrics such as movement for foraging. The example below is set at 100m for foraging (note assume short distance for demonstration only. )

```{r, echo = FALSE, message = FALSE, warning = FALSE}

## actual data analysis
bb <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |>
  filter(breeding == "y") |>
  filter(tag.id == 262940) |>
  st_transform(bb, crs = 3573)

bb <- cbind(st_coordinates(bb), bb)

bbsp <- bb |>
  sf::st_drop_geometry() |>
  dplyr::filter(argos.lc %in% c(2, 3)) |>
  dplyr::select(X, Y, timestamp, tag.id) |>
  dplyr::mutate(t = lubridate::ymd_hms(timestamp)) |>
  dplyr::select(-timestamp) |>
  mutate(tag.id = as.character(tag.id)) |>
  dplyr::select(X, Y, t, tag.id)

bbvisit <- getRecursions(bbsp, 100)

par(mfrow = c(1, 2), mar = c(4, 4, 1, 1))
plot(bbvisit, bbsp, legendPos = c(13, -10))

drawCircle(-15, -10, 2)

hist(bbvisit$revisits, breaks = 20, main = "", xlab = "Revisits (radius = 1500m)")
```

We can then use K measn clustering to identify nests based on revisit location and frequency. 

```{r echo = FALSE, message = FALSE, warning = FALSE}

# K - means clustering
visitThreshold <- quantile(bbvisit$revisits, 0.8)
popCluster <- kmeans(bbsp[bbvisit$revisits > visitThreshold, c("X", "Y")], centers = 1)

plot(bbsp$X, bbsp$Y, # col = c("red", "darkblue")[as.numeric(bbsp$tag.id)],
  pch = ".", xlab = "x", ylab = "y", asp = 1
)
with(
  bbsp[bbvisit$revisits > visitThreshold, ],
  points(X, Y,
    col = alpha("red", 0.5), # c(alpha("red", 0.5), alpha("darkblue", 0.5))[as.numeric(bbsp$tag.id)],
    pch = c(15:17)[popCluster$cluster]
  )
)
legend("topleft", pch = 15:17, legend = paste("cluster", 1), bty = "n")


```


#3) NestR package

This package uses similar approach to asses nest locations based on biological parameters and GPS locations. 



```{r, eval = FALSE, echo = FALSE, message = FALSE, warning = FALSE}

bb_all <- st_read(path("temp", "full_breeding_ids_label.gpkg"), quiet = TRUE) |>
  filter(breeding == "y") |>
  filter(tag.id == 262940) |>
  filter(argos.lc %in% c("3", "2")) |>
  dplyr::mutate(date = lubridate::ymd_hms(timestamp)) |>
  mutate(burst = paste0(tag.id, "-", year))

bb <- cbind(st_coordinates(bb_all), bb_all)
bb <- bb |>
  rename(
    "long" = "X",
    "lat" = "Y"
  ) |>
  st_drop_geometry() |>
  dplyr::select(burst, date, tag.id, long, lat)


# atempt to find nests

ws_output_1 <- find_nests(
  gps_data = bb,
  sea_start = "06-01",
  sea_end = "07-05",
  nest_cycle = 34,
  buffer = 1000,
  min_pts = 2,
  min_d_fix = 5,
  min_consec = 2,
  min_top_att = 1,
  min_days_att = 1,
  discard_overlapping = FALSE
)

#ws_output_1

#head(ws_output_1$nests)

#table(ws_output_1$nests$burst)

# output nests as an sf object
ws_nests <- ws_output_1$nests |>
  st_as_sf(coords = c("long", "lat"), crs = 4326) |>
  mutate(nest_id = row_number())

## Step 3: Identifying nests among revisited locations

ws_output_2 <- find_nests(
  gps_data = bb,
  sea_start = "06-01",
  sea_end = "07-05",
  nest_cycle = 34,
  buffer = 1000,
  min_pts = 2,
  min_d_fix = 5,
  min_consec = 2,
  min_top_att = 1,
  min_days_att = 1,
  discard_overlapping = TRUE
)

# output nests as an sf object
ws_nests2 <- ws_output_2$nests |>
  st_as_sf(coords = c("long", "lat"), crs = 4326) |>
  mutate(nest_id = row_number())


# plot the nests

ggplot() +
  geom_sf(data = bb_all, aes(colour = argos.lc), size = 1, alpha = 0.1) +
  #geom_sf(data = ws_nests, size = 2) +
  geom_sf(data = ws_nests2, size = 2) +
  #scale_colour_viridis_d() +
  theme_bw()

```




